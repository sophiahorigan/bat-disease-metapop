N_pop = vec(N_tot) # by disease status
M_pop = vec(t(N_tot)) # by age class
# make matrix to store your population as you go
N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
N_pop_ts[,1] <- M_pop # by age class
##################################
## Update stable age structure?? why?
##################################
stab.struct <- get.age.struct.M(M_pop, c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
##################################
## Iterate through timesteps
##################################
for (i in 1:(length(times)-1)){
# build matrices anew each time because foi depends on # infected
# calculate biweek from timestep here:
biwk1 <- find.biweek(t=i, times=times)
# generate SIR matrix
Tmat <- buildTMat_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk=age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick,	beta=beta, sigma=sigma, recov=recov,  wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr)
# generate fecundity matrix
Fmat <- buildFMatrix(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1)
# make transition mat
transMat <- Tmat + Fmat
#move forward in time
nt1<-(transMat) %*% N_pop_ts[,i]
N_pop_ts[,i+1] <- nt1
}
##############################
## Update stable structure
#############################
stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
######################
## Sum age classes
#####################
# split matrix into age classes
N_split_pop = mat_split(N_pop_ts, r=c, c=ncol(N_pop_ts))
# transform array into list and populate
pop.list = list()
for (i in 1:dim(N_split_pop)[3]){
pop.list[[i]] = N_split_pop[,,i]
}
# then take column sums of each
pop.sum = lapply(X=pop.list, FUN = colSums)
##################################
## Sum disease state variables
#################################
# split matrix into state variables
N_split_disease = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
# transform array into list and populate
disease.list = list()
for (i in 1:dim(N_split_disease)[3]){
disease.list[[i]] = N_split_disease[,,i]
}
# then take column sums of each
disease.sum = lapply(X=pop.list, FUN = colSums)
################################
## Clean population dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.pop = cbind.data.frame(times, pop.sum)
names(dat.tot.pop) = c("time", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20")
dat.tot.pop$tot_pop = rowSums((dat.tot.pop[,2:ncol(dat.tot.pop)]))
dat.long.pop <- melt(dat.tot.pop, measure.vars = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "tot_pop"), variable.name = "age", value.name = "count")
dat.sub.pop = subset(dat.long.pop, age!="tot_pop")
dat.pop.pop = subset(dat.long.pop, age=="tot_pop")
dat.pop.pop <- dplyr::select(dat.pop.pop, -(age))
names(dat.pop.pop)[names(dat.pop.pop)=="count"] <- "tot_pop"
dat.out.pop <- merge(dat.sub.pop, dat.pop.pop, by ="time", all.x = T, sort = F)
head(dat.out.pop)
dat.out.pop$proportion <- dat.out.pop$count/dat.out.pop$tot_pop
dat.out.pop$age = factor(dat.out.pop$age, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"))
# assign adult and juvenile categorization
for(i in 1:nrow(dat.out.pop)){
if(dat.out.pop[i,"age"] == 1){dat.out.pop[i, "class"] = 'J'}
if(dat.out.pop[i,"age"] != 1){dat.out.pop[i, "class"] = 'A'}
}
dat.out.pop = subset(dat.out.pop, time >= burnin)
################################
## Clean disease dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.disease = cbind.data.frame(times, disease.sum)
names(dat.tot.disease) = c("time", "M", "S", "I", "R")
dat.tot.disease$tot_pop = rowSums((dat.tot.disease[,2:ncol(dat.tot.disease)]))
#print(dat.tot$tot_pop)
dat.long.disease <- melt(dat.tot.disease, measure.vars = c("M", "S", "I", "R", "tot_pop"), variable.name = "state", value.name = "count")
dat.sub.disease = subset(dat.long.disease, state!="tot_pop")
dat.pop.disease = subset(dat.long.disease, state=="tot_pop")
dat.pop.disease <- dplyr::select(dat.pop.disease, -(state))
names(dat.pop.disease)[names(dat.pop.disease)=="count"] <- "tot_pop"
dat.out.disease <- merge(dat.sub.disease, dat.pop.disease, by ="time", all.x = T, sort = F)
#head(dat.out.disease)
dat.out.disease$proportion <- dat.out.disease$count/dat.out.disease$tot_pop
dat.out.disease$state = factor(dat.out.disease$state, levels=c("M", "S", "I", "R"))
dat.out.disease = subset(dat.out.disease, time >= burnin)
# CAN ONLY RETURN ONE ARRAY IN R SO DUMB
# NEED TO FIGURE OUT HOW TO COMBINE THEM BAH
if(printpop == TRUE){
return(dat.out.pop)
}
if(printpop == FALSE){
return(dat.out.disease)
}
}
##################
## RUN MODEL
#################
printpop = TRUE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRS <- sim.met.MSIR.age(burnin=0,
sim_pop=10000,
yrs=1,
ntyr=26,
s=20,
beta = 1.57911,
age.brk = 20,
recov=1,
mort=.207,
mort_juv=0.456,
adult_fec=.48,
wane=1.08806987767265, #(3^(1/26))
sigma=0.0222735363575397,
mu.sick = 1,
add.inf.mort = FALSE,
printpop=printpop)
# simulate model
sim.met.MSIR.age <- function(burnin, sim_pop, yrs, ntyr, age.brk, s, beta, recov, mort, mort_juv, adult_fec, wane, sigma, mu.sick, add.inf.mort, printpop){
#################################
## Generate stable age structure
################################
# num columns
c=4 # M, S, I, R
# generate time seq
times <-   seq(0, yrs, by =1/ntyr)
# Take our juvenile and adult survival rates and use them to get the stable age structure
mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
stab.struct = Re(eigen(mat1)$vector[,1])
stab.struct <- stab.struct/sum(stab.struct)
# plot(stab.struct, xlab="Age", ylab="Proportion")
####################################################################
## Use stable age structure to generate bat population for time seq
####################################################################
# check lambda
lambda = round(max(Re(eigen(mat1)$value)), 8)
#print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
# gives counts of bats per age year
bat.mat = stab.struct*sim_pop
######################################################
## Initiate infection and run dynamics to equilibrium
######################################################
# introduce a few infecteds and run it out to equilibrium before you grab the data
R_init = rep(0, s)
I_init = rep(0, s); I_init[3] = 5
M_init = rep(0, s)
S_init = bat.mat - I_init
N_tot = cbind(M_init, S_init, I_init, R_init)
N_pop = vec(N_tot) # by disease status
M_pop = vec(t(N_tot)) # by age class
# make matrix to store your population as you go
N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
N_pop_ts[,1] <- M_pop # by age class
##################################
## Update stable age structure?? why?
##################################
stab.struct <- get.age.struct.M(M_pop, c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
##################################
## Iterate through timesteps
##################################
for (i in 1:(length(times)-1)){
# build matrices anew each time because foi depends on # infected
# calculate biweek from timestep here:
biwk1 <- find.biweek(t=i, times=times)
# generate SIR matrix
Tmat <- buildTMat_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk=age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick,	beta=beta, sigma=sigma, recov=recov,  wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr)
# generate fecundity matrix
Fmat <- buildFMatrix(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1)
# make transition mat
transMat <- Tmat + Fmat
#move forward in time
nt1<-(transMat) %*% N_pop_ts[,i]
N_pop_ts[,i+1] <- nt1
}
##############################
## Update stable structure
#############################
stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
######################
## Sum age classes
#####################
# split matrix into age classes
N_split_pop = mat_split(N_pop_ts, r=c, c=ncol(N_pop_ts))
# transform array into list and populate
pop.list = list()
for (i in 1:dim(N_split_pop)[3]){
pop.list[[i]] = N_split_pop[,,i]
}
# then take column sums of each
pop.sum = lapply(X=pop.list, FUN = colSums)
##################################
## Sum disease state variables
#################################
# split matrix into state variables
N_split_disease = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
# transform array into list and populate
disease.list = list()
for (i in 1:dim(N_split_disease)[3]){
disease.list[[i]] = N_split_disease[,,i]
}
# then take column sums of each
disease.sum = lapply(X=pop.list, FUN = colSums)
################################
## Clean population dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.pop = cbind.data.frame(times, pop.sum)
names(dat.tot.pop) = c("time", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20")
dat.tot.pop$tot_pop = rowSums((dat.tot.pop[,2:ncol(dat.tot.pop)]))
dat.long.pop <- melt(dat.tot.pop, measure.vars = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "tot_pop"), variable.name = "age", value.name = "count")
dat.sub.pop = subset(dat.long.pop, age!="tot_pop")
dat.pop.pop = subset(dat.long.pop, age=="tot_pop")
dat.pop.pop <- dplyr::select(dat.pop.pop, -(age))
names(dat.pop.pop)[names(dat.pop.pop)=="count"] <- "tot_pop"
dat.out.pop <- merge(dat.sub.pop, dat.pop.pop, by ="time", all.x = T, sort = F)
head(dat.out.pop)
dat.out.pop$proportion <- dat.out.pop$count/dat.out.pop$tot_pop
dat.out.pop$age = factor(dat.out.pop$age, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"))
# assign adult and juvenile categorization
for(i in 1:nrow(dat.out.pop)){
if(dat.out.pop[i,"age"] == 1){dat.out.pop[i, "class"] = 'J'}
if(dat.out.pop[i,"age"] != 1){dat.out.pop[i, "class"] = 'A'}
}
dat.out.pop = subset(dat.out.pop, time >= burnin)
################################
## Clean disease dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.disease = cbind.data.frame(times, disease.sum)
names(dat.tot.disease) = c("time", "M", "S", "I", "R")
dat.tot.disease$tot_pop = rowSums((dat.tot.disease[,2:ncol(dat.tot.disease)]))
#print(dat.tot$tot_pop)
dat.long.disease <- melt(dat.tot.disease, measure.vars = c("M", "S", "I", "R", "tot_pop"), variable.name = "state", value.name = "count")
dat.sub.disease = subset(dat.long.disease, state!="tot_pop")
dat.pop.disease = subset(dat.long.disease, state=="tot_pop")
dat.pop.disease <- dplyr::select(dat.pop.disease, -(state))
names(dat.pop.disease)[names(dat.pop.disease)=="count"] <- "tot_pop"
dat.out.disease <- merge(dat.sub.disease, dat.pop.disease, by ="time", all.x = T, sort = F)
#head(dat.out.disease)
dat.out.disease$proportion <- dat.out.disease$count/dat.out.disease$tot_pop
dat.out.disease$state = factor(dat.out.disease$state, levels=c("M", "S", "I", "R"))
dat.out.disease = subset(dat.out.disease, time >= burnin)
# CAN ONLY RETURN ONE ARRAY IN R SO DUMB
# NEED TO FIGURE OUT HOW TO COMBINE THEM BAH
if(printpop == TRUE){
return(dat.out.pop)
}
if(printpop == FALSE){
return(dat.out.disease)
}
}
run.sim.MSIRS <- sim.met.MSIR.age(burnin=0,
sim_pop=10000,
yrs=1,
ntyr=26,
s=20,
beta = 1.57911,
age.brk = 20,
recov=1,
mort=.207,
mort_juv=0.456,
adult_fec=.48,
wane=1.08806987767265, #(3^(1/26))
sigma=0.0222735363575397,
mu.sick = 1,
add.inf.mort = FALSE,
printpop=printpop)
##################
## RUN MODEL
#################
printpop = FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRS <- sim.met.MSIR.age(burnin=0,
sim_pop=10000,
yrs=1,
ntyr=26,
s=20,
beta = 1.57911,
age.brk = 20,
recov=1,
mort=.207,
mort_juv=0.456,
adult_fec=.48,
wane=1.08806987767265, #(3^(1/26))
sigma=0.0222735363575397,
mu.sick = 1,
add.inf.mort = FALSE,
printpop=printpop)
# simulate model
sim.met.MSIR.age <- function(burnin, sim_pop, yrs, ntyr, age.brk, s, beta, recov, mort, mort_juv, adult_fec, wane, sigma, mu.sick, add.inf.mort, printpop){
#################################
## Generate stable age structure
################################
# num columns
c=4 # M, S, I, R
# generate time seq
times <-   seq(0, yrs, by =1/ntyr)
# Take our juvenile and adult survival rates and use them to get the stable age structure
mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
stab.struct = Re(eigen(mat1)$vector[,1])
stab.struct <- stab.struct/sum(stab.struct)
# plot(stab.struct, xlab="Age", ylab="Proportion")
####################################################################
## Use stable age structure to generate bat population for time seq
####################################################################
# check lambda
lambda = round(max(Re(eigen(mat1)$value)), 8)
#print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
# gives counts of bats per age year
bat.mat = stab.struct*sim_pop
######################################################
## Initiate infection and run dynamics to equilibrium
######################################################
# introduce a few infecteds and run it out to equilibrium before you grab the data
R_init = rep(0, s)
I_init = rep(0, s); I_init[3] = 5
M_init = rep(0, s)
S_init = bat.mat - I_init
N_tot = cbind(M_init, S_init, I_init, R_init)
N_pop = vec(N_tot) # by disease status
M_pop = vec(t(N_tot)) # by age class
# make matrix to store your population as you go
N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
N_pop_ts[,1] <- M_pop # by age class
##################################
## Update stable age structure?? why?
##################################
stab.struct <- get.age.struct.M(M_pop, c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
##################################
## Iterate through timesteps
##################################
for (i in 1:(length(times)-1)){
# build matrices anew each time because foi depends on # infected
# calculate biweek from timestep here:
biwk1 <- find.biweek(t=i, times=times)
# generate SIR matrix
Tmat <- buildTMat_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk=age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick,	beta=beta, sigma=sigma, recov=recov,  wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr)
# generate fecundity matrix
Fmat <- buildFMatrix(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1)
# make transition mat
transMat <- Tmat + Fmat
#move forward in time
nt1<-(transMat) %*% N_pop_ts[,i]
N_pop_ts[,i+1] <- nt1
}
##############################
## Update stable structure
#############################
stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion")
N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
######################
## Sum age classes
#####################
# split matrix into age classes
N_split_pop = mat_split(N_pop_ts, r=c, c=ncol(N_pop_ts))
# transform array into list and populate
pop.list = list()
for (i in 1:dim(N_split_pop)[3]){
pop.list[[i]] = N_split_pop[,,i]
}
# then take column sums of each
pop.sum = lapply(X=pop.list, FUN = colSums)
##################################
## Sum disease state variables
#################################
# split matrix into state variables
N_split_disease = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
# transform array into list and populate
disease.list = list()
for (i in 1:dim(N_split_disease)[3]){
disease.list[[i]] = N_split_disease[,,i]
}
# then take column sums of each
disease.sum = lapply(X=disease.list, FUN = colSums)
################################
## Clean population dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.pop = cbind.data.frame(times, pop.sum)
names(dat.tot.pop) = c("time", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20")
dat.tot.pop$tot_pop = rowSums((dat.tot.pop[,2:ncol(dat.tot.pop)]))
dat.long.pop <- melt(dat.tot.pop, measure.vars = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "tot_pop"), variable.name = "age", value.name = "count")
dat.sub.pop = subset(dat.long.pop, age!="tot_pop")
dat.pop.pop = subset(dat.long.pop, age=="tot_pop")
dat.pop.pop <- dplyr::select(dat.pop.pop, -(age))
names(dat.pop.pop)[names(dat.pop.pop)=="count"] <- "tot_pop"
dat.out.pop <- merge(dat.sub.pop, dat.pop.pop, by ="time", all.x = T, sort = F)
head(dat.out.pop)
dat.out.pop$proportion <- dat.out.pop$count/dat.out.pop$tot_pop
dat.out.pop$age = factor(dat.out.pop$age, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"))
# assign adult and juvenile categorization
for(i in 1:nrow(dat.out.pop)){
if(dat.out.pop[i,"age"] == 1){dat.out.pop[i, "class"] = 'J'}
if(dat.out.pop[i,"age"] != 1){dat.out.pop[i, "class"] = 'A'}
}
dat.out.pop = subset(dat.out.pop, time >= burnin)
################################
## Clean disease dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.disease = cbind.data.frame(times, disease.sum)
names(dat.tot.disease) = c("time", "M", "S", "I", "R")
dat.tot.disease$tot_pop = rowSums((dat.tot.disease[,2:ncol(dat.tot.disease)]))
#print(dat.tot$tot_pop)
dat.long.disease <- melt(dat.tot.disease, measure.vars = c("M", "S", "I", "R", "tot_pop"), variable.name = "state", value.name = "count")
dat.sub.disease = subset(dat.long.disease, state!="tot_pop")
dat.pop.disease = subset(dat.long.disease, state=="tot_pop")
dat.pop.disease <- dplyr::select(dat.pop.disease, -(state))
names(dat.pop.disease)[names(dat.pop.disease)=="count"] <- "tot_pop"
dat.out.disease <- merge(dat.sub.disease, dat.pop.disease, by ="time", all.x = T, sort = F)
#head(dat.out.disease)
dat.out.disease$proportion <- dat.out.disease$count/dat.out.disease$tot_pop
dat.out.disease$state = factor(dat.out.disease$state, levels=c("M", "S", "I", "R"))
dat.out.disease = subset(dat.out.disease, time >= burnin)
# CAN ONLY RETURN ONE ARRAY IN R SO DUMB
# NEED TO FIGURE OUT HOW TO COMBINE THEM BAH
if(printpop == TRUE){
return(dat.out.pop)
}
if(printpop == FALSE){
return(dat.out.disease)
}
}
##################
## RUN MODEL
#################
printpop = FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRS <- sim.met.MSIR.age(burnin=0,
sim_pop=10000,
yrs=1,
ntyr=26,
s=20,
beta = 1.57911,
age.brk = 20,
recov=1,
mort=.207,
mort_juv=0.456,
adult_fec=.48,
wane=1.08806987767265, #(3^(1/26))
sigma=0.0222735363575397,
mu.sick = 1,
add.inf.mort = FALSE,
printpop=printpop)
##################
## RUN MODEL
#################
printpop = TRUE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRS <- sim.met.MSIR.age(burnin=0,
sim_pop=10000,
yrs=1,
ntyr=26,
s=20,
beta = 1.57911,
age.brk = 20,
recov=1,
mort=.207,
mort_juv=0.456,
adult_fec=.48,
wane=1.08806987767265, #(3^(1/26))
sigma=0.0222735363575397,
mu.sick = 1,
add.inf.mort = FALSE,
printpop=printpop)
#######################
## PLOTTING POPULATION
######################
# MSIRS
if (printpop == TRUE){
# by age
p2_msirs <- ggplot(data=run.sim.MSIRS) + geom_line(aes(x=time, y=count, color=age)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
#scale_color_manual(values=colz) +
scale_x_continuous(breaks=seq(0, max(run.sim.MSIRS$time), 1)) + ggtitle("MSIRS") +
xlab("Year")
p2_msirs + geom_line(aes(x=time, y=tot_pop))
p2_msirs
}
if (printpop == TRUE){
# by class
agg_adjuv <- aggregate(run.sim.MSIRS$count, by=list(run.sim.MSIRS$time, run.sim.MSIRS$class), FUN=sum)
colnames(agg_adjuv) = c("time", "class", "count")
p3_msirs <- ggplot(data=agg_adjuv) + geom_line(aes(x=time, y=count, color=class)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
scale_x_continuous(breaks=seq(0, max(run.sim.MSIRS$time), 1)) + ggtitle("MSIRS") +
xlab("Year")
p3_msirs
}
