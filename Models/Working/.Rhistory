names(dat.tot.disease) = c("time", "M", "S", "I", "R", "N")
dat.tot.disease$tot_pop = rowSums((dat.tot.disease[,2:ncol(dat.tot.disease)]))
#print(dat.tot$tot_pop)
dat.long.disease <- melt(dat.tot.disease, measure.vars = c("M", "S", "I", "R", "N", "tot_pop"), variable.name = "state", value.name = "count")
dat.sub.disease = subset(dat.long.disease, state!="tot_pop")
dat.pop.disease = subset(dat.long.disease, state=="tot_pop")
dat.pop.disease <- dplyr::select(dat.pop.disease, -(state))
names(dat.pop.disease)[names(dat.pop.disease)=="count"] <- "tot_pop"
dat.out.disease <- merge(dat.sub.disease, dat.pop.disease, by ="time", all.x = T, sort = F)
#head(dat.out.disease)
dat.out.disease$proportion <- dat.out.disease$count/dat.out.disease$tot_pop
dat.out.disease$state = factor(dat.out.disease$state, levels=c("M", "S", "I", "R", "N"))
dat.out.disease = subset(dat.out.disease, time >= burnin)
# CAN ONLY RETURN ONE ARRAY IN R SO DUMB
# NEED TO FIGURE OUT HOW TO COMBINE THEM BAH
if(printpop == TRUE){
return(dat.out.pop)
}
if(printpop == FALSE){
return(dat.out.disease)
}
}
##################
## RUN MODEL
#################
printpop == FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRN <- sim.met.MSIRN.age(burnin=0,                  # years to ditch at start of sim
sim_pop=1000,               # population size
yrs=10,                     # years for simulation
ntyr=26,                   # model timestep - greatly changes dynamics!
s=20,                       # number of age classes
beta = 2.203968,            # transmission
age.brk = 20,               # how many distinct age classes there are
recov=1,                    # recovery rate
mort=.207,                  # adult natural mortality
mort_juv=0.456,             # mortality juvenile
adult_fec=.48,              # adult fecundity
wane=0.0850142487956748,    # rate of waning maternal immunity - fixed
slope.wane=1,               # slope for waning maternal immunity - logistic regression
sigma=0.00748049787194744,  # waning adult humoral immunity
rho=0,                      # this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
mu.sick = 1,                # increased mortality rate for infected individuals
add.inf.mort = FALSE,       # increased mortatlity rate for infected juveniles also?
N_stat = "matAB",             # N class mothers produce M class young
printpop = FALSE)            # print age class dynamics instead of infection dynamics
beep()
#######################
### PLOTTING INFECTION
#######################
if (printpop == FALSE){
colz = c('M'="violet", 'S' = "mediumseagreen", 'I' = 'tomato', 'R' = "cornflowerblue", 'N' = "navy")
p1 <- ggplot(data=run.sim.MSIRN) + geom_line(aes(x=time, y=proportion, color=state)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
scale_color_manual(values=colz) +
xlab("Year")
p1
}
#######################
## PLOTTING POPULATION
######################
if (printpop == TRUE){
# by age
p2 <- ggplot(data=run.sim.MSIRN) + geom_line(aes(x=time, y=count, color=age)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
#scale_color_manual(values=colz) +
xlab("Year")
p2 + geom_line(aes(x=time, y=tot_pop))
p2
}
########################
## SIMULATE MSIRN ##
#######################
# Created by Sophia Horigan (shorigan@uchicago.edu)
# Started: 01-17-24
# Last updated: 01-19-24
# Goal: Get MSIRM model working
# Project Overview: This project seeks to use existing demographic data and the current best-fit transmission model
# to explore persistence threshholds for hypothetical pathogens under data-based metapopulation structure of Pteropus
# rufus in Madagascar.
## PART 1 : SIMULATE MSIRN MODEL
# set model parameters
# function : run model
# plotting :
# statistics : AP (annual persistence: with prob > 50% infection will persist in population for 1 year)
#           : LP (long-term persisence: with prob > 50% infection will persist in population for 100 years)
#rm(list=ls())
# Accomplishments
# 01-17-24 removed all model simulation except MSRIN, and removed extraneous functions
# 01-19-24 modified main simulation matrix to also produce a dataframe tracking age class dynamics, including changing variable names
# To Do
# Figure out how to return both disease and population dataframes from main function (different dims)
# move helper functions to a different script to get them out of the way?
# investigate how initial infection count changes dynamics
# deep dive 'biweek' see if/how it differs from nyat of 26
library(dplyr)
library(plyr)
library(cowplot)
library(deSolve)
library(lubridate)
library(matrixcalc)
library(Matrix)
library(ggplot2)
library(reshape2)
library(beepr)
##########################
## Helper Functions
##########################
transform.vect <- function(vec, s, c){ # vector, rows, columns
vec2 <- t(commutation.matrix(r=s,c=c))%*%vec
return(vec2)
}
mat_split <- function(M, r, c){
nr <- ceiling(nrow(M)/r)
nc <- ceiling(ncol(M)/c)
newM <- matrix(NA, nr*r, nc*c)
newM[1:nrow(M), 1:ncol(M)] <- M
div_k <- kronecker(matrix(seq_len(nr*nc), nr, byrow = TRUE), matrix(1, r, c))
matlist <- split(newM, div_k)
N <- length(matlist)
mats <- unlist(matlist)
dim(mats)<-c(r, c, N)
return(mats)
}#for matrix slicing. give it the number of rows and columns you want in the resulting matrices
find.biweek = function(t, times){
biwks <- sort(unique(round(revtrunc(times),4)))
this.wk = round(revtrunc(times[t]), 4)
this.biwk <- which(biwks==this.wk)
return(this.biwk)
}
revtrunc = function(x){
newx = x - floor(x)
return(newx)
}
##########################
## Matrix Functions
##########################
# population matrix
build.pop.mat = function(surv, surv_juv, s, adult_fec){
pop.mat = matrix(0,  nrow=(s-1), ncol = (s-1))
diag(pop.mat) = surv
diag(pop.mat)[1] = surv_juv
col_s = c(rep(0, s-2), surv)
pop.mat = cbind(pop.mat, col_s)
row1 = c(0, rep((adult_fec*surv), (s-1))) #bats reproduce for the first time at the end of the second year of life. good for E. dup and P. ruf
pop.mat = rbind(row1,pop.mat)
return(pop.mat)
}#for stable age distribution
get.age.struct.M = function(pop, c){ # function that collapses population vector in disease state form to age structure
age.mat <- mat_split(M=matrix(pop, ncol=1), r=c, c=1)
age.mat.list <- c()
for (i in 1:dim(age.mat)[3]){
age.mat.list[[i]] <- age.mat[,,i]
}
#zage.mat <- Reduce('+', age.mat.list)
age.mat <- lapply(age.mat.list, sum)
age.mat.dat <- c( c(1:length(age.mat)), unlist(age.mat))
names(age.mat.dat) <- c("age", "pop")
return(age.mat)
}
# disease matrix
buildTMat_MSIRN_age <- function(c, Npop, age.classes, surv.biwk, age.brk, surv.juv.biwk, mu.sick, rho, beta, recov, sigma, wane, add.inf.mort, age.rate, slope.wane){
##########################
## Set up Parameters
##########################
# num age classes
s <- nage <- length(age.classes)
# mortality
mort.vect <- c((1-surv.juv.biwk), rep((1-surv.biwk), (nage-1)))
# transmission
if (length(beta)==1) beta <- rep(beta,nage) # same transmission for each age class
if (length(beta)==s) beta <- beta           # different transmission rates for each age class
if (length(beta) > 1 & length(beta)<s){.    # ??
beta.list <- list()
for (i in 1:length(beta)){
beta.list[[i]] = rep(beta[i], age.brk[i])
}
beta = c(unlist(beta.list))
}
# waning adult humoral immunity
if (length(sigma)==1) sigma <- rep(sigma,nage) # same sigma for each age class
# increased mortality rate for infected individuals
if (length(mu.sick)==1) mu.sick <- rep(mu.sick, nage) # same mu.sick for each age class
# ??
if (length(age.rate)==1) age.rate <- rep(age.rate, nage) # same age.rate for each age class
# ate of waning maternal immunity - fixed
if (length(wane)==1) wane <- rep(wane,nage) # same wane for each age class
waning.maternal = wane
# density dependent transmission
# get population size
Npop_epi <- transform.vect(vec=Npop, s=s, c=c)
# calculate infecteds
I_m = mat_split(matrix(Npop_epi, ncol=1), r=s, c=1)[,,3] # I is in position 3
# vector of force of infection
foi = 1-exp(-beta*(sum(I_m)/sum(Npop_epi)))
##############################
## Populate Infection Matrix
##############################
mat1 <- matrix(0,5,5) # MSIRN
Tmat <- matrix(0,5*nage,5*nage) # MSIRN for every age cohort
for (j in 1:nage) {     # fill in epi matrix for each age class. this gives probability of transmission per biweek for the model
mat1[] <- 0
mat1[1,1] <- 1- waning.maternal[j]
mat1[2,1] <- waning.maternal[j]
mat1[2,2] <- 1-foi[j]
mat1[3,2] <- foi[j]
mat1[3,3] <- 1-recov
mat1[3,5] <- rho
mat1[4,3] <- recov
mat1[4,4] <- 1-sigma[j]
mat1[5,4] <- sigma[j]
mat1[5,5] <- 1-rho
# survival
surv <- rep(1-mort.vect[j],5); # equal across all age groups
# optional : add infection-induced mortality
if (add.inf.mort==TRUE){
surv[3] <- pmax(1-(mu.sick[j]*mort.vect[j]),0) # 3 is infected position
}
##################################
## Update State Variable Matrix
#################################
if (j!=nage) {       # if you are not in the last age class, you go into next age class
# infection matrix, survival, and aging
Tmat[(j*5+1):(j*5+5),((j-1)*5+1):(j*5)] <- mat1*surv*age.rate[j]
# infection matrix, survival, NO aging
Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv*(1-age.rate[j]) # not sure how this is decided
## do i need to consider any of this?
#except for the maternally immune - we don't let them transition between infection states
#but maybe we do!
#here, we ammend the epidemic transition matrix accordingly
#mat2 <- mat1; mat2[1,1] <- 1; mat2[2,1] <- 0
#and we fill in all the maternally immune correspondingly
#when age.rate=1, this is 0, meaning that there is no survival across maternally immune categories--
#you change class when you age up - this essentially says that for those that don't age up, if maternally immune, they stay in their current class. i think i disagree...
#but we let that maternally immune class have a different aging rate (<1 year)
#Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat2*surv*(1-age.rate[j])
#Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv*(age.rate[j])
}
else {
# stay in this age class if you are at the peak age
Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv
}
}
return(Tmat)
}
# fecundity matrix
buildFMatrix_MSIRN <- function(age.classes, adult_fec, surv.biwk, biwk, N_stat){
################################
## Set timing of birth rates
###############################
if(biwk==1){
new.fec = adult_fec*surv.biwk*.3
}else if (biwk==2|biwk==26){
new.fec = adult_fec*surv.biwk*.25
}else if (biwk==3|biwk==25){
new.fec = adult_fec*surv.biwk*.1
#}else if (biwk==4|biwk ==24){
#new.fec = adult_fec*surv.biwk*.05
}else{
new.fec = 0
}
####################
## Set up matrix
###################
s <- nage <- length(age.classes)
# compile into fecundity for each age class
fert.biwk <- c(0,rep(new.fec,(s-1)))
Fmat <- matrix(0,5*nage,5*nage)
############################
## Update fertility matrix
###########################
for (j in 1:nage) { # no fertility in first age class
# try it assuming N moms produce maternally immune pups
Fmat[1,((j-1)*5+1):(j*5)] <- c(0,0,fert.biwk[j],fert.biwk[j], fert.biwk[j]) # the mat immune (so mom = I and R but not N)
Fmat[2,((j-1)*5+1):(j*5)]<-  c(fert.biwk[j],fert.biwk[j],0,0, 0) # the susceptible (mom didn't get sick, so mom= N and S)
}
return(Fmat)
}
# simulate model
sim.met.MSIRN.age <- function(burnin, sim_pop, yrs, ntyr, s, beta, age.brk, recov, mort, mort_juv, adult_fec, wane, rho, slope.wane, sigma, mu.sick, add.inf.mort, N_stat, printpop){
#################################
## Generate stable age structure
################################
# num columns - in this case M, S, I, R, N
c=5
# generate time seq
times <- seq(0, yrs, by = 1/ntyr)
# Take juvenile and adult survival rates and use them to get the stable age structure
mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
stab.struct = Re(eigen(mat1)$vector[,1])
stab.struct <- stab.struct/sum(stab.struct)
#plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
####################################################################
## Use stable age structure to generate bat population for time seq
####################################################################
# check lambda
lambda = round(max(Re(eigen(mat1)$value)), 8)
#print(paste0("lambda = ", lambda))
# gives counts of bats per age year
bat.mat = stab.struct*sim_pop
######################################################
## Initiate infection and run dynamics to equilibrium
######################################################
# introduce a few infecteds and run it out to equilibrium before you grab the data
R_init = rep(0, s)
I_init = rep(0, s); I_init[3] = 5 # does this initial value change dynamics much?
M_init = rep(0, s)
N_init = rep(0, s)
S_init = bat.mat - I_init
N_tot = cbind(M_init, S_init, I_init, R_init, N_init)
N_pop = vec(N_tot) # by disease status
M_pop = vec(t(N_tot)) # by age class
# make matrix to store your population as you go
N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
N_pop_ts[,1] <- M_pop # by age class
##################################
## Update stable age structure?? why?
##################################
stab.struct <- get.age.struct.M(M_pop, c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
##################################
## Iterate through timesteps
##################################
for (i in 1:(length(times)-1)){
# build matrices anew each time because foi depends on # infected
# calculate biweek from timestep here:
biwk1 <- find.biweek(t=i, times=times) # what is a biweek? different than selecting 26 for ntyr?
# generate SIR matrix
Tmat <- buildTMat_MSIRN_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk = age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick, rho=rho,	beta=beta, sigma=sigma, recov=recov, wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
# generate fecundity matrix
Fmat <- buildFMatrix_MSIRN(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1, N_stat = N_stat)
# make trans mat
transMat <- Tmat + Fmat
# move forward in time
nt1 <- (transMat) %*% N_pop_ts[,i]
N_pop_ts[,i+1] <- nt1
}
##############################
## Update stable structure
#############################
stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
stab.struct <- c(unlist(stab.struct))
stab.struct <- stab.struct/(sum(stab.struct))
#plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
######################
## Sum age classes
#####################
# split matrix into age classes
N_split_pop = mat_split(N_pop_ts, r=5, c=ncol(N_pop_ts))
# transform matrix into list and populate
pop.list = list()
for (i in 1:dim(N_split_pop)[3]){
pop.list[[i]] = N_split_pop[,,i]
}
# then take column sums of each and plot the class totals over time
pop.sum = lapply(X=pop.list, FUN=colSums)
##################################
## Sum disease state variables
#################################
# split matrix into state variables
N_split_disease = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
#transform array into list
disease.list = list()
for (i in 1:dim(N_split_disease)[3]){
disease.list[[i]] = N_split_disease[,,i]
}
# then take column sums of each and plot the state variable totals over time
disease.sum = lapply(X=disease.list, FUN=colSums)
################################
## Clean population dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.pop = cbind.data.frame(times, pop.sum)
names(dat.tot.pop) = c("time", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20")
dat.tot.pop$tot_pop = rowSums((dat.tot.pop[,2:ncol(dat.tot.pop)]))
#print(dat.tot.pop$tot_pop)
dat.long.pop <- melt(dat.tot.pop, measure.vars = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "tot_pop"), variable.name = "age", value.name = "count")
dat.sub.pop = subset(dat.long.pop, age!="tot_pop")
dat.pop.pop = subset(dat.long.pop, age=="tot_pop")
dat.pop.pop <- dplyr::select(dat.pop.pop, -(age))
names(dat.pop.pop)[names(dat.pop.pop)=="count"] <- "tot_pop"
dat.out.pop <- merge(dat.sub.pop, dat.pop.pop, by ="time", all.x = T, sort = F)
head(dat.out.pop)
dat.out.pop$proportion <- dat.out.pop$count/dat.out.pop$tot_pop
dat.out.pop$age = factor(dat.out.pop$age, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"))
# assign adult and juvenile categorization
for(i in 1:nrow(dat.out.pop)){
if(dat.out.pop[i,"age"] == 1){dat.out.pop[i, "class"] = 'J'}
if(dat.out.pop[i,"age"] != 1){dat.out.pop[i, "class"] = 'A'}
}
dat.out.pop = subset(dat.out.pop, time >= burnin)
################################
## Clean disease dataframe
###############################
#times=seq(0,yrs,by =1/ntyr)
dat.tot.disease = cbind.data.frame(times, disease.sum)
names(dat.tot.disease) = c("time", "M", "S", "I", "R", "N")
dat.tot.disease$tot_pop = rowSums((dat.tot.disease[,2:ncol(dat.tot.disease)]))
#print(dat.tot$tot_pop)
dat.long.disease <- melt(dat.tot.disease, measure.vars = c("M", "S", "I", "R", "N", "tot_pop"), variable.name = "state", value.name = "count")
dat.sub.disease = subset(dat.long.disease, state!="tot_pop")
dat.pop.disease = subset(dat.long.disease, state=="tot_pop")
dat.pop.disease <- dplyr::select(dat.pop.disease, -(state))
names(dat.pop.disease)[names(dat.pop.disease)=="count"] <- "tot_pop"
dat.out.disease <- merge(dat.sub.disease, dat.pop.disease, by ="time", all.x = T, sort = F)
#head(dat.out.disease)
dat.out.disease$proportion <- dat.out.disease$count/dat.out.disease$tot_pop
dat.out.disease$state = factor(dat.out.disease$state, levels=c("M", "S", "I", "R", "N"))
dat.out.disease = subset(dat.out.disease, time >= burnin)
# CAN ONLY RETURN ONE ARRAY IN R SO DUMB
# NEED TO FIGURE OUT HOW TO COMBINE THEM BAH
if(printpop == TRUE){
return(dat.out.pop)
}
if(printpop == FALSE){
return(dat.out.disease)
}
}
##################
## RUN MODEL
#################
printpop == FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRN <- sim.met.MSIRN.age(burnin=0,                  # years to ditch at start of sim
sim_pop=1000,               # population size
yrs=10,                     # years for simulation
ntyr=26,                   # model timestep - greatly changes dynamics!
s=20,                       # number of age classes
beta = 2.203968,            # transmission
age.brk = 20,               # how many distinct age classes there are
recov=1,                    # recovery rate
mort=.207,                  # adult natural mortality
mort_juv=0.456,             # mortality juvenile
adult_fec=.48,              # adult fecundity
wane=0.0850142487956748,    # rate of waning maternal immunity - fixed
slope.wane=1,               # slope for waning maternal immunity - logistic regression
sigma=0.00748049787194744,  # waning adult humoral immunity
rho=0,                      # this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
mu.sick = 1,                # increased mortality rate for infected individuals
add.inf.mort = FALSE,       # increased mortatlity rate for infected juveniles also?
N_stat = "matAB",             # N class mothers produce M class young
printpop = FALSE)            # print age class dynamics instead of infection dynamics
beep()
#######################
### PLOTTING INFECTION
#######################
if (printpop = FALSE){
View(run.sim.MSIRN)
##################
## RUN MODEL
#################
printpop == FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
##################
## RUN MODEL
#################
printpop = FALSE # TRUE for printing population dynamics, FALSE for printing disease dynamics
run.sim.MSIRN <- sim.met.MSIRN.age(burnin=0,                  # years to ditch at start of sim
sim_pop=1000,               # population size
yrs=10,                     # years for simulation
ntyr=26,                   # model timestep - greatly changes dynamics!
s=20,                       # number of age classes
beta = 2.203968,            # transmission
age.brk = 20,               # how many distinct age classes there are
recov=1,                    # recovery rate
mort=.207,                  # adult natural mortality
mort_juv=0.456,             # mortality juvenile
adult_fec=.48,              # adult fecundity
wane=0.0850142487956748,    # rate of waning maternal immunity - fixed
slope.wane=1,               # slope for waning maternal immunity - logistic regression
sigma=0.00748049787194744,  # waning adult humoral immunity
rho=0,                      # this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
mu.sick = 1,                # increased mortality rate for infected individuals
add.inf.mort = FALSE,       # increased mortatlity rate for infected juveniles also?
N_stat = "matAB",             # N class mothers produce M class young
printpop = printpop)            # print age class dynamics instead of infection dynamics
if (printpop == FALSE){
colz = c('M'="violet", 'S' = "mediumseagreen", 'I' = 'tomato', 'R' = "cornflowerblue", 'N' = "navy")
p1 <- ggplot(data=run.sim.MSIRN) + geom_line(aes(x=time, y=proportion, color=state)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
scale_color_manual(values=colz) +
xlab("Year")
p1
}
#######################
## PLOTTING POPULATION
######################
if (printpop == TRUE){
# by age
p2 <- ggplot(data=run.sim.MSIRN) + geom_line(aes(x=time, y=count, color=age)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
#scale_color_manual(values=colz) +
xlab("Year")
p2 + geom_line(aes(x=time, y=tot_pop))
p2
}
if (printpop == TRUE){
# by class
agg_adjuv <- aggregate(run.sim.MSIRN$count, by=list(run.sim.MSIRN$time, run.sim.MSIRN$class), FUN=sum)
colnames(agg_adjuv) = c("time", "class", "count")
p3 <- ggplot(data=agg_adjuv) + geom_line(aes(x=time, y=count, color=class)) +
theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white")) +
xlab("Year")
p3
}
#ggsave(file = "MSIRN.png",
#      plot=p1,
#     units="mm",
#    width=30,
#   height=60,
#  scale=3,
# dpi=300)
