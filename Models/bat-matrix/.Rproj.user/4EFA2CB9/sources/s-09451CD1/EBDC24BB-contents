rm(list=ls())

library(dplyr)
library(plyr)
library(cowplot)
library(deSolve)
library(lubridate)
library(matrixcalc)
library(Matrix)
library(dplyr)
library(plyr)
library(ggplot2)
library(reshape2)


#simulate three models and plot with no vaccines

#load your functions
buildTMat_age <- function(c, Npop, age.classes, surv.biwk, age.brk, surv.juv.biwk, mu.sick,	beta, recov, sigma, wane, add.inf.mort, age.rate, slope.wane){
  
  s <- nage <- length(age.classes)
  
  mort.vect <- c((1-surv.juv.biwk), rep((1-surv.biwk), (nage-1))) 
  
  #first, set up beta:
  if (length(beta)==1) beta <- rep(beta,nage) # 
  if (length(beta)==s) beta <- beta
  if (length(beta) > 1 & length(beta)<s){
    beta.list <- list()
    for (i in 1:length(beta)){
      beta.list[[i]] = rep(beta[i], age.brk[i])
    }
    beta = c(unlist(beta.list))
  } 
  #if (length(sero)==1) sero <- rep(sero,nage) # we assume the pop is perfectly mixed so this is irrelevant
  #if (length(boost)==1) boost <- rep(boost,nage) # we assume the pop is perfectly mixed so this is irrelevant
  if (length(sigma)==1) sigma <- rep(sigma,nage)
  if (length(mu.sick)==1) mu.sick <- rep(mu.sick, nage)
  if (length(age.rate)==1) age.rate <- rep(age.rate,nage)
  if (length(wane)==1) wane <- rep(wane,nage)
  waning.maternal = wane
  
  
  #use logisitc regression - now with justin's amendment (i.e. correct for going in and out of classes)
  #waning.maternal.here<-1-(exp(pmin(-wane+slope.wane*c(0,age.classes),20))/
  #                          (1+exp(pmin(-wane+slope.wane*c(0,age.classes),20))))
  #waning.maternal <- (waning.maternal.here[1:length(age.classes)]-
  #                     waning.maternal.here[2:(1+length(age.classes))])/waning.maternal.here[1:length(age.classes)]
  #waning.maternal[waning.maternal.here[1:length(age.classes)]<1e-8] <- 1
  
  #assume density dependent transmission - means you need the total infectious pop, so you need to isolate that first thing
  #first, transform to get all the infecteds together
  Npop_epi <- transform.vect(vec=Npop, s=s, c=c)
  I_m = mat_split(matrix(Npop_epi, ncol=1), r=s, c=1)[,,3] #always. for all model forms, I comes #3
  #foi = 1-exp(-beta*sum(I_m))
  #psi = 1-exp(-sero*sum(I_m)) #force of seroconversion, also depends on density of I class
  foi = 1-exp(-beta*(sum(I_m)/sum(Npop_epi))) #vector
  #psi = 1-exp(-sero*(sum(I_m)/sum(Npop_epi))) #force of seroconversion, also depends on density of I class
  
  
  mat1 <- matrix(0,4,4) # MSIR
  
  Tmat <- matrix(0,4*nage,4*nage) #MSIR for every age cohort
  for (j in 1:nage) {
    
    #fill in epi matrix for each age class. this gives probability of transmission per biweek for a MSIR/MSIRS/MSRIR model
    mat1[] <- 0
    mat1[1,1] <- 1- waning.maternal[j]
    mat1[2,1] <- waning.maternal[j]
    mat1[2,2] <- 1-foi[j]#-psi
    mat1[3,2] <- foi[j]
    mat1[3,3] <- 1-recov
    #mat1[4,2] <- psi
    mat1[4,3] <- recov
    mat1[4,4] <- 1-sigma[j] #already included here. simply give sigma a value if you want to allow for waning immunity
    mat1[2,4] <- sigma[j]
    
    #put in surv. we first say it is equal across all infectious classes
    surv <- rep(1-mort.vect[j],4);
    
    #if we decide to add infection-induced mortality, we can do so here by replacing survival for the infecteds
    #in this case, looks like sick are only slighly more likely to add. option here will make them definitely die
    if (add.inf.mort==TRUE){ #we'll let seropositives die more too
      surv[3] <- pmax(1-(mu.sick[j]*mort.vect[j]),0)
      # surv[4] <- pmax(1-(mu.sick[j]*mort.vect[j]),0)
    } 
    #print(c(j,surv[3]))
    #fill in Tmatrix
    if (j!=nage) { 
      #if you are not in the last age class, you go into next age class
      #multiply infection transitions times survival and aging rates
      Tmat[(j*4+1):(j*4+4),((j-1)*4+1):(j*4)] <- mat1*surv*age.rate[j]
      
      #except for the maternally immune - we don't let them transition between infection states
      #but maybe we do!
      #here, we ammend the epidemic transition matrix accordingly
      mat2 <- mat1; mat2[1,1] <- 1; mat2[2,1] <- 0
      
      #and we fill in all the maternally immune correspondingly
      #when age.rate=1, this is 0, meaning that there is no survival across maternally immune categories--
      #you change class when you age up
      Tmat[((j-1)*4+1):(j*4),((j-1)*4+1):(j*4)] <- mat2*surv*(1-age.rate[j])
      
    } else {
      #stay in this age class if you are at the peak age
      Tmat[((j-1)*4+1):(j*4),((j-1)*4+1):(j*4)] <- mat1*surv
      
      
    }
    
  }
  
  return(Tmat)
  
}
buildTMat_MSIRN_age <- function(c, Npop, age.classes, surv.biwk, age.brk, surv.juv.biwk, mu.sick, rho, beta, recov, sigma, wane, add.inf.mort, age.rate, slope.wane){
  
  s <- nage <- length(age.classes)
  
  #put the mortality rates end-to-end
  mort.vect <- c((1-surv.juv.biwk), rep((1-surv.biwk), (nage-1))) 
  
  #first, set up beta:
  if (length(beta)==1) beta <- rep(beta,nage) # 
  if (length(beta)==s) beta <- beta
  if (length(beta) > 1 & length(beta)<s){
    beta.list <- list()
    for (i in 1:length(beta)){
      beta.list[[i]] = rep(beta[i], age.brk[i])
    }
    beta = c(unlist(beta.list))
  } 
  #if (length(sero)==1) sero <- rep(sero,nage) 
  #if (length(boost)==1) boost <- rep(boost,nage) 
  if (length(sigma)==1) sigma <- rep(sigma,nage)
  if (length(mu.sick)==1) mu.sick <- rep(mu.sick, nage)
  if (length(age.rate)==1) age.rate <- rep(age.rate,nage)
  if (length(wane)==1) wane <- rep(wane,nage)
  waning.maternal = wane
  
  #then adjust the aging rate for age class 1 to reflect duration of mat. immunity
  #age.rate[1] = waning.maternal[1]
  
  
  #use logisitc regression - now with justin's amendment (i.e. correct for going in and out of classes)
  #try without
  #waning.maternal.here<-1-(exp(pmin(-wane+slope.wane*c(0,age.classes),20))/
  #                          (1+exp(pmin(-wane+slope.wane*c(0,age.classes),20))))
  #waning.maternal <- (waning.maternal.here[1:length(age.classes)]-
  #                     waning.maternal.here[2:(1+length(age.classes))])/waning.maternal.here[1:length(age.classes)]
  #waning.maternal[waning.maternal.here[1:length(age.classes)]<1e-8] <- 1
  
  #assume density dependent transmission - means you need the total infectious pop, so you need to isolate that first thing
  #first, transform to get all the infecteds together
  Npop_epi <- transform.vect(vec=Npop, s=s, c=c)
  I_m = mat_split(matrix(Npop_epi, ncol=1), r=s, c=1)[,,3] #always. for all model forms, I comes #3
  #foi = 1-exp(-beta*sum(I_m))
  foi = 1-exp(-beta*(sum(I_m)/sum(Npop_epi))) #will produce a vector. if there was structure in the age-contacts we would feed it a contact matrix too, but here we assume age classes are evenly mixed
  
  
  mat1 <- matrix(0,5,5) # MSIRN
  
  Tmat <- matrix(0,5*nage,5*nage) #MSIRN for every age cohort
  for (j in 1:nage) {
    
    #fill in epi matrix for each age class. this gives probability of transmission per biweek for a MSIR/MSIRS/MSRIR model
    mat1[] <- 0
    mat1[1,1] <- 1- waning.maternal[j]
    mat1[2,1] <- waning.maternal[j]
    mat1[2,2] <- 1-foi[j]
    mat1[3,2] <- foi[j]
    mat1[3,3] <- 1-recov
    mat1[3,5] <- rho
    mat1[4,3] <- recov
    mat1[4,4] <- 1-sigma[j] #already included here. simply give sigma a value if you want to allow for waning immunity
    mat1[5,4] <- sigma[j]
    mat1[5,5] <- 1-rho
    
    #put in surv. we first say it is equal across all infectious classes
    surv <- rep(1-mort.vect[j],5);
    
    #if we decide to add infection-induced mortality, we can do so here by replacing survival for the infecteds
    #in this case, looks like sick are only slighly more likely to add. option here will make them definitely die
    if (add.inf.mort==TRUE){
      surv[3] <- pmax(1-(mu.sick[j]*mort.vect[j]),0)
      #surv[4] <- pmax(1-(mu.sick[j]*mort.vect[j]),0)
    } 
    #print(c(j,surv[3]))
    #fill in Tmatrix
    if (j!=nage) { 
      #if you are not in the last age class, you go into next age class
      #multiply infection transitions times survival and aging rates
      Tmat[(j*5+1):(j*5+5),((j-1)*5+1):(j*5)] <- mat1*surv*age.rate[j]
      
      #and those that do not age are also subject to their own survival and transition rates:
      Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv*(1-age.rate[j])
      
      
      #except for the maternally immune - we don't let them transition between infection states
      #but maybe we do!
      #here, we ammend the epidemic transition matrix accordingly
      #mat2 <- mat1; mat2[1,1] <- 1; mat2[2,1] <- 0
      
      #and we fill in all the maternally immune correspondingly
      #when age.rate=1, this is 0, meaning that there is no survival across maternally immune categories--
      #you change class when you age up - this essentially says that for those that don't age up, if maternally immune, they stay in their current class. i think i disagree...
      #but we let that maternally immune class have a different aging rate (<1 year)
      #Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat2*surv*(1-age.rate[j])
      #Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv*(age.rate[j])
      
    } else {
      #stay in this age class if you are at the peak age
      Tmat[((j-1)*5+1):(j*5),((j-1)*5+1):(j*5)] <- mat1*surv
      
      
    }
    
  }
  
  return(Tmat)
  
}
buildFMatrix <- function(age.classes, adult_fec, surv.biwk, biwk){ 	#one for every age class
  #base your fertility on the biweek of the year
  #pop will grow a bit because higher chance of surviving to birth when births come earlier
  #but these total to the annual fec rate
  if(biwk==1){ #peak births
    new.fec = adult_fec*surv.biwk*.3
  }else if (biwk==2|biwk==26){
    new.fec = adult_fec*surv.biwk*.2
  }else if (biwk==3|biwk==25){
    new.fec = adult_fec*surv.biwk*.1
  }else if (biwk==4|biwk ==24){
    new.fec = adult_fec*surv.biwk*.05
  }else{
    new.fec = 0
  }
  s <- nage <- length(age.classes)
  
  fert.biwk <- c(0,rep(new.fec,(s-1)))
  
  
  
  #make matrix the same size as the transition
  Fmat <- matrix(0,4*nage,4*nage)
  
  for (j in 1:nage) {
    Fmat[1,((j-1)*4+1):(j*4)] <- c(0,0,fert.biwk[j],fert.biwk[j]) #the mat immune
    Fmat[2,((j-1)*4+1):(j*4)]<- c(fert.biwk[j],fert.biwk[j],0,0) #the susceptible (mom didn't get sick)
  }
  
  return(Fmat)
}
buildFMatrix_MSIRN <- function(age.classes, adult_fec, surv.biwk, biwk, N_stat){ 	#one for every age class
  #base your fertility on the biweek of the year
  #pop will grow a bit because higher chance of surviving to birth when births come earlier
  #but these total to the annual fec rate
  
  if(biwk==1){ #peak births
    new.fec = adult_fec*surv.biwk*.3
  }else if (biwk==2|biwk==26){
    new.fec = adult_fec*surv.biwk*.25
  }else if (biwk==3|biwk==25){
    new.fec = adult_fec*surv.biwk*.1
    #}else if (biwk==4|biwk ==24){
    #new.fec = adult_fec*surv.biwk*.05
  }else{
    new.fec = 0
  }
  s <- nage <- length(age.classes)
  
  fert.biwk <- c(0,rep(new.fec,(s-1)))
  
  
  
  #make matrix the same size as the transition
  Fmat <- matrix(0,5*nage,5*nage)
  
  for (j in 1:nage) { #no fertility in first age class (mat immune)
    if(N_stat=="matAB"){
      #try it assuming N moms produce maternally immune pups
      Fmat[1,((j-1)*5+1):(j*5)] <- c(0,0,fert.biwk[j],fert.biwk[j], fert.biwk[j]) #the mat immune (so mom = I and R but not N)
      Fmat[2,((j-1)*5+1):(j*5)]<-  c(fert.biwk[j],fert.biwk[j],0,0, 0) #the susceptible (mom didn't get sick, so mom= N and S)
      
    }else if (N_stat=="matSus"){
      Fmat[1,((j-1)*5+1):(j*5)] <- c(0,0,fert.biwk[j],fert.biwk[j], 0) #the mat immune (so mom = I and R but not N)
      Fmat[2,((j-1)*5+1):(j*5)]<- c(fert.biwk[j],fert.biwk[j],0,0, fert.biwk[j]) #the susceptible (mom didn't get sick, so mom= N and S)
    }
    
    
    
  }
  
  return(Fmat)
}
transform.vect <- function(vec, s, c){
  vec2 <- t(commutation.matrix(r=s,c=c))%*%vec
  return(vec2)
}
find.biweek = function(t, times){
  
  biwks <- sort(unique(round(revtrunc(times),4)))
  this.wk = round(revtrunc(times[t]), 4)
  this.biwk <- which(biwks==this.wk)
  
  
  return(this.biwk)
  
  
}
get.age.struct = function(pop, s){ #function that collapses population vector in disease state form to age structure
  age.mat <- mat_split(M=matrix(pop, ncol=1), r=s, c=1)
  age.mat.list <- c()
  for (i in 1:dim(age.mat)[3]){
    age.mat.list[[i]] <- age.mat[,,i]
  }
  age.mat <- Reduce('+', age.mat.list)
  return(age.mat)
}
get.age.struct.M = function(pop, c){ #function that collapses population vector in disease state form to age structure
  age.mat <- mat_split(M=matrix(pop, ncol=1), r=c, c=1)
  age.mat.list <- c()
  for (i in 1:dim(age.mat)[3]){
    age.mat.list[[i]] <- age.mat[,,i]
  }
  #zage.mat <- Reduce('+', age.mat.list)
  age.mat <- lapply(age.mat.list, sum)
  age.mat.dat <- c( c(1:length(age.mat)), unlist(age.mat))
  names(age.mat.dat) <- c("age", "pop")
  return(age.mat)
}
prev.by.age <- function(dat){
  dat$n_age = sum(dat$count)
  dat$prev = dat$count/dat$n_age
  #and seroprev
  dat$seropos = sum(dat$count[dat$class=="M"], dat$count[dat$class=="R"])
  dat$seroprev = dat$seropos/dat$n_age
  return(dat)
}
revtrunc = function(x){
  newx = x - floor(x)
  return(newx)
}
spline.fit = function(data){
  #replace any Inf vals only the okay values
  #data <- data[complete.cases(data),]
  data$seroprevalence[data$seroprevalence==Inf] <- 1
  data$seroprevalence[data$seroprevalence<0] <- 0
  # if(length(data$age)>1){
  spline1 = with(data, smooth.spline(x=age, y=seroprevalence)) 
  #  return(spline1)
  # }else{
  #  return(NA)
  #  }
}
pred.fit <- function(spline1, ages.new){
  prev.comp = predict(spline1, x=ages.new)
  return(prev.comp$y)
}
get.seas.seroprev = function(dat){
  #get doy in bat calendar
  #convert to biweek
  #calc seroprev by biweek
  
  dat$doy <- yday(dat$date)
  #now correct for birthday of bat in questiob
  if(unique(dat$species=="Pteropus rufus")){
    bday <- yday("2015-10-01") #320
  } else if(unique(dat$species=="Eidolon dupreanum")){
    bday = yday("2015-11-01")
  }
  #write over for doy
  dat$new_doy = NA
  for (i in 1:length(dat$doy)){
    if(dat$doy[i] > bday){
      dat$new_doy[i] <- dat$doy[i] - bday
    } else if (dat$doy[i] <= bday){
      dat$new_doy[i] <- dat$doy[i] + (365-bday)
    }
  }
  
  dat$doy <- dat$new_doy
  dat <- dplyr::select(dat, -(new_doy))
  
  #now convert to biweek
  dat$biwk <- NA
  brk <- seq(0,365, by=14)
  for (i in 1:length(dat$biwk)){
    tmp <- brk[dat$doy[i] >=  brk]
    tmp2 <- tmp[length(tmp)] 
    dat$biwk[i] <- which(brk==tmp2)
  }
  
  #now calc seroprev by biweek
  biwk.sero <- ddply(dat, .(biwk), summarize, seropos = sum(prev), sero_lci = sum(prev_lci), sero_uci = sum(prev_uci), n=length(prev))  
  biwk.sero$seroprev = biwk.sero$seropos/biwk.sero$n
  biwk.sero$seroprev_lci = biwk.sero$sero_lci/biwk.sero$n
  biwk.sero$seroprev_uci = biwk.sero$sero_uci/biwk.sero$n
  biwk.sero$biwk = as.numeric(biwk.sero$biwk)
  
  return(biwk.sero)
}
get.mod.seas = function(mod.out){
  #convert time to doy
  mod.out$doy = mod.out$time*365
  #then to biwk
  brk <- seq(0,365, by=14) #doy breaks by biweek
  brk <- brk[-length(brk)]
  #brk.seq = 1:length(brk)
  mod.out$biwk <- NA
  for (i in 1:length(mod.out$biwk)){
    tmp <- brk[mod.out$doy[i] >=  brk]
    tmp2 <- tmp[length(tmp)] 
    mod.out$biwk[i] <- which(brk==tmp2)
  }
  #then return
  return(mod.out)
}
age.sero.plot = function(dat){
  with(dat, plot(age, seroprevalence, type = "b", ylim=c(0,1)))
}
get.seroprev.dat = function(data, vis_split, cutoff){
  
  visbin = seq(3,floor(max(data$age)), vis_split)
  #but breakdown the early years into more
  visbin = c(c(0,.5, 1, 2),   visbin)
  data$age_year <- NA
  
  for (i in 1:length(data$age_year)){
    tmp = visbin[data$age[i] > visbin]
    data$age_year[i] <- tmp[length(tmp)] 
  }
  
  if(cutoff=="mean"){
    dat.sum2 <- ddply(data, .(age_year), summarize,  prevalence=sum(prev)/length(prev), count=length(prev))  
  }else if (cutoff=="uci"){
    dat.sum2 <- ddply(data, .(age_year), summarize,  prevalence=sum(prev_uci)/length(prev_uci), count=length(prev_uci)) 
  }else if (cutoff=="lci"){
    dat.sum2 <- ddply(data, .(age_year), summarize,  prevalence=sum(prev_lci)/length(prev_lci), count=length(prev_lci)) 
  }
  
  #you want the midpoint between either end of the age class now
  vect.age.yr = sort(unique(data$age_year))
  dat.sum2$age_plot = NA
  
  for (i in 1:(length(dat.sum2$age_year)-1)){
    dat.sum2$age_plot [i] = ((dat.sum2$age_year[i + 1] - dat.sum2$age_year[i])/2) + dat.sum2$age_year[i]
  }
  dat.sum2$age_plot[length(dat.sum2$age_plot)] =  (ceiling(max(data$age)) - dat.sum2$age_year[length(dat.sum2$age_year)])/2  + dat.sum2$age_year[length(dat.sum2$age_year)]
  
  names(dat.sum2)  <- c("real_age", "prevalence", "count", "age_year") #<- names(dat.sum2.tmp)
  
  # dat.sum2 <-  rbind(dat.sum2.tmp, dat.sum2)
  
  dat.sum3 = dat.sum2
  dat.sum3$class = "seropositive"
  rownames(dat.sum3) <- c()
  
  return(dat.sum3)
  
}
build.pop.mat = function(surv, surv_juv, s, adult_fec){
  pop.mat = matrix(0,  nrow=(s-1), ncol = (s-1))
  diag(pop.mat) = surv
  diag(pop.mat)[1] = surv_juv
  col_s = c(rep(0, s-2), surv)
  pop.mat = cbind(pop.mat, col_s)
  row1 = c(0, rep((adult_fec*surv), (s-1))) #bats reproduce for the first time at the end of the second year of life. good for E. dup and P. ruf
  pop.mat = rbind(row1,pop.mat)
  return(pop.mat)
  
}#for stable age distribution
mat_split <- function(M, r, c){
  nr <- ceiling(nrow(M)/r)
  nc <- ceiling(ncol(M)/c)
  newM <- matrix(NA, nr*r, nc*c)
  newM[1:nrow(M), 1:ncol(M)] <- M
  
  div_k <- kronecker(matrix(seq_len(nr*nc), nr, byrow = TRUE), matrix(1, r, c))
  matlist <- split(newM, div_k)
  N <- length(matlist)
  mats <- unlist(matlist)
  dim(mats)<-c(r, c, N)
  return(mats)
}#for matrix slicing. give it the number of rows and columns you want in the resulting matrices
stack.age = function(dat, s){
  dat.new= list()
  for (i in 1:s){
    dat.new[[i]] = dat[i,]
  }
  dat.new = c(unlist(dat.new))
  return(dat.new)
}
stack.class = function(mat.dat, c){
  
  new.dat = list()
  for (i in 1:c){
    new.dat[[i]] = mat.dat[i,]
  }
  new.dat = c(unlist(new.dat))
  return(new.dat)
}


sim.met.MSIR.age <- function(burnin, sim_pop, yrs, ntyr, age.brk, s, beta, recov, mort, mort_juv, adult_fec, wane, slope.wane, sigma, mu.sick, add.inf.mort){
  
  c=4
  
  #then run model for 100 years 
  #can take more timesteps than the data
  times <-   seq(0, yrs, by =1/ntyr) # then, subtract last few biweeks so you end before the last birthpulse starts. 
  #means ctting last 4 biweeks
  #times <- times[1:(length(times)-4)]
  
  
  
  #first, we take our juvenile and adult survival rates and use them to get the stable age structure
  mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
  
  stab.struct = Re(eigen(mat1)$vector[,1])
  stab.struct <- stab.struct/sum(stab.struct)
  # plot(stab.struct, xlab="Age", ylab="Proportion")
  
  #out of curiosity...
  lambda = round(max(Re(eigen(mat1)$value)), 8)
  #print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
  #then, we use this stable age structure to make a bat population
  #gives counts of bats per age year
  bat.mat = stab.struct*sim_pop
  
  #introduce a few infecteds and run it out to equilibrium before you grab the data
  R_init = rep(0, s)
  I_init = rep(0, s); I_init[3] = 5 #comment out if you just want to check demography
  M_init = rep(0, s)
  S_init = bat.mat - I_init 
  
  
  N_tot = cbind(M_init, S_init, I_init, R_init)
  
  N_pop = vec(N_tot) #by disease status
  M_pop = vec(t(N_tot)) #by age class
  
  #make matrix to store your population as you go
  N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
  N_pop_ts[,1] <- M_pop # by age class
  
  
  stab.struct <- get.age.struct.M(M_pop, c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion")
  
  
  #print("start ts")
  #iterate SIR such that this gets transitioned each timestep. And change the births as you go
  for (i in 1:(length(times)-1)){
    
    
    #build matrices anew each time because foi depends on # infected
    #print(i)
    Tmat <- buildTMat_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk=age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick,	beta=beta, sigma=sigma, recov=recov,  wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    #print(i)
    
    #calculate biweek from timestep here:
    biwk1 <- find.biweek(t=i, times=times)
    #print(biwk1)
    
    
    #feed biweek into fertility matrix: since births only happen during certain times of the year
    #births happen in biweeks 1-4, 24-26
    Fmat <- buildFMatrix(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1)
    
    #make trans mat
    transMat <- Tmat + Fmat 
    
    #move forward in time
    nt1<-(transMat) %*% N_pop_ts[,i]
    
    #fill in to matrix
    N_pop_ts[,i+1] <- nt1
    
    
  }
  
  stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion")  
  
  #transform whole vector to be split by class instead of age
  N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
  
  
  N_split_1 = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
  
  #transform array into list
  N_split = list()
  for (i in 1:dim(N_split_1)[3]){
    N_split[[i]] = N_split_1[,,i]
  }
  
  #now you have a list of state variables.
  #then take column sums of each and plot the class totals over time - note that there are 26 steps per year
  N_total = lapply(X=N_split, FUN=colSums)
  
  #plot both by age and total
  #times=seq(0,yrs,by =1/ntyr)
  dat.tot = cbind.data.frame(times,N_total)
  names(dat.tot) = c("time", "M", "S", "I", "R")
  dat.tot$N = rowSums((dat.tot[,2:ncol(dat.tot)]))
 
  
  names(dat.tot)[names(dat.tot)=="N"] <- "tot_pop"
  
  
  dat.long <- melt(dat.tot, measure.vars = c("M", "S", "I", "R", "tot_pop"), variable.name = "state", value.name = "count")
  dat.sub = subset(dat.long, state!="tot_pop")
  dat.pop = subset(dat.long, state=="tot_pop")
  
  dat.pop <- dplyr::select(dat.pop, -(state))
  names(dat.pop)[names(dat.pop)=="count"] <- "tot_pop"
  
  dat.out <- merge(dat.sub, dat.pop, by ="time", all.x = T, sort = F)
  head(dat.out)
  dat.out$proportion <- dat.out$count/dat.out$tot_pop
  
  dat.out$state = factor(dat.out$state, levels=c("M", "S", "I", "R"))
  
  #and remove burnin:
  dat.out = subset(dat.out, time >= burnin)
  
  
  #return this sim
  return(dat.out)
  
}
sim.met.MSIRN.age <- function(burnin, sim_pop, yrs, ntyr,  s, beta, age.brk, recov, mort, mort_juv, adult_fec, wane, rho, slope.wane, sigma, mu.sick, add.inf.mort, N_stat){
  #first pull out your data...
  c=5
  # dat.tmp <- subset(dat.age1, species==species1 & type==type1)
  #then run model for 100 years 
  #can take more timesteps than the data
  times <-   seq(0, yrs, by =1/ntyr) # then, subtract last few biweeks so you end before the last birthpulse starts. 
  #means ctting last 4 biweeks
  #times <- times[1:(length(times)-4)]
  
  
  
  #first, we take our juvenile and adult survival rates and use them to get the stable age structure
  mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
  
  stab.struct = Re(eigen(mat1)$vector[,1])
  stab.struct <- stab.struct/sum(stab.struct)
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
  
  #out of curiosity...
  lambda = round(max(Re(eigen(mat1)$value)), 8)
  #print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
  #then, we use this stable age structure to make a bat population
  #gives counts of bats per age year
  bat.mat = stab.struct*sim_pop
  
  #introduce a few infecteds and run it out to equilibrium before you grab the data
  R_init = rep(0, s)
  I_init = rep(0, s); I_init[3] = 5 #comment out if you just want to check demography
  M_init = rep(0, s)
  N_init = rep(0, s)
  S_init = bat.mat - I_init 
  
  
  N_tot = cbind(M_init, S_init, I_init, R_init, N_init)
  
  N_pop = vec(N_tot) #by disease status
  M_pop = vec(t(N_tot)) #by age class
  
  #make matrix to store your population as you go
  N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
  N_pop_ts[,1] <- M_pop # by age class
  
  
  stab.struct <- get.age.struct.M(M_pop, c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
  
  
  # print("start ts")
  #iterate SIR such that this gets transitioned each timestep. And change the births as you go
  for (i in 1:(length(times)-1)){
    #build matrices anew each time because foi depends on # infected
    #calculate biweek from timestep here:
    biwk1 <- find.biweek(t=i, times=times)
    #  print(i)
    Tmat <- buildTMat_MSIRN_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk = age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick, rho=rho,	beta=beta, sigma=sigma, recov=recov, wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    
    
    #Tmat <- buildTMat_MSIRN_age_seas(biwk=biwk1, c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk = age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick, boost=boost,	beta=beta, sigma=sigma, recov=recov, wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    # print(i)
    
    # print(biwk1)
    
    #feed into fertility matrix since births are dependent on biwk
    Fmat <- buildFMatrix_MSIRN(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1, N_stat = N_stat)
    
    #make trans mat
    transMat <- Tmat + Fmat 
    
    #move forward in time
    nt1<-(transMat) %*% N_pop_ts[,i]
    N_pop_ts[,i+1] <- nt1
  }
  
  stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")  
  
  #transform whole vector to be split by class instead of age
  N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
  
  
  N_split_1 = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
  
  #transform array into list
  N_split = list()
  for (i in 1:dim(N_split_1)[3]){
    N_split[[i]] = N_split_1[,,i]
  }
  
  #now you have a list of state variables.
  #then take column sums of each and plot the class totals over time - note that there are 26 steps per year
  N_total = lapply(X=N_split, FUN=colSums)
  
  #plot both by age and total
  #times=seq(0,yrs,by =1/ntyr)
  dat.tot = cbind.data.frame(times,N_total)
  names(dat.tot) = c("time", "M", "S", "I", "R", "N")
  dat.tot$tot_pop = rowSums((dat.tot[,2:ncol(dat.tot)]))
  
  
  
  dat.long <- melt(dat.tot, measure.vars = c("M", "S", "I", "R", "N", "tot_pop"), variable.name = "state", value.name = "count")
  dat.sub = subset(dat.long, state!="tot_pop")
  dat.pop = subset(dat.long, state=="tot_pop")
  
  dat.pop <- dplyr::select(dat.pop, -(state))
  names(dat.pop)[names(dat.pop)=="count"] <- "tot_pop"
  
  dat.out <- merge(dat.sub, dat.pop, by ="time", all.x = T, sort = F)
  head(dat.out)
  dat.out$proportion <- dat.out$count/dat.out$tot_pop
  
  dat.out$state = factor(dat.out$state, levels=c("M", "S", "I", "R", "N"))
  
  #and remove burnin:
  dat.out = subset(dat.out, time >= burnin)
  
  
  #return this sim
  return(dat.out)
}
sim.met.MSIR.age.vax <- function(burnin, sim_pop, yrs, ntyr, age.brk, s, beta, recov, mort, mort_juv, adult_fec, model1,
                                 wane, slope.wane, sigma, mu.sick, add.inf.mort, vacc.biwk, prop.vacc, year.vacc){
  
  c=4
  
  #then run model for 100 years 
  #can take more timesteps than the data
  times <-   seq(0, yrs, by =1/ntyr) # then, subtract last few biweeks so you end before the last birthpulse starts. 
  #means ctting last 4 biweeks
  #times <- times[1:(length(times)-4)]
  
  
  
  #first, we take our juvenile and adult survival rates and use them to get the stable age structure
  mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
  
  stab.struct = Re(eigen(mat1)$vector[,1])
  stab.struct <- stab.struct/sum(stab.struct)
  # plot(stab.struct, xlab="Age", ylab="Proportion")
  
  #out of curiosity...
  lambda = round(max(Re(eigen(mat1)$value)), 8)
  #print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
  #then, we use this stable age structure to make a bat population
  #gives counts of bats per age year
  bat.mat = stab.struct*sim_pop
  
  #introduce a few infecteds and run it out to equilibrium before you grab the data
  R_init = rep(0, s)
  I_init = rep(0, s); I_init[3] = 5 #comment out if you just want to check demography
  M_init = rep(0, s)
  S_init = bat.mat - I_init 
  
  
  N_tot = cbind(M_init, S_init, I_init, R_init)
  
  N_pop = vec(N_tot) #by disease status
  M_pop = vec(t(N_tot)) #by age class
  
  #make matrix to store your population as you go
  N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
  N_pop_ts[,1] <- M_pop # by age class
  
  
  stab.struct <- get.age.struct.M(M_pop, c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion")
  
  
  #print("start ts")
  #iterate SIR such that this gets transitioned each timestep. And change the births as you go
  for (i in 1:(length(times)-1)){
    
    
    #build matrices anew each time because foi depends on # infected
    #print(i)
    Tmat <- buildTMat_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk=age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick,	beta=beta, sigma=sigma, recov=recov,  wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    #print(i)
    
    #calculate biweek from timestep here:
    biwk1 <- find.biweek(t=i, times=times)
    #print(biwk1)
    
    
    #feed biweek into fertility matrix: since births only happen during certain times of the year
    Fmat <- buildFMatrix(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1)
    
    #make trans mat
    transMat <- Tmat + Fmat 
    
    #move forward in time
    nt1<-(transMat) %*% N_pop_ts[,i]
    
    #then, add in vaccination event, depending on the biweek of the year
    if (sum(biwk1==vacc.biwk)>0 & floor(times[i])==year.vacc){
      #pop vector right now is organized by age class: M-1,S-1,I-1,R-1,M-2,S-2, etc.
      
      #move to by disease status
      #transform whole vector to be split by class instead of age
      nt1_disease <- transform.vect(vec=nt1, s=s, c=c)
      
      #now, move a proportion of the S class individuals to the R class for vaccination
      S.move <- nt1_disease[(s+1):(s+s)]*prop.vacc
      
      #take them out of S
      nt1_disease[(s+1):(s+s)] <- (nt1_disease[(s+1):(s+s)]-S.move)
      
      #put them in R
      
      nt1_disease[(3*s+1):(3*s+s)] <- nt1_disease[(3*s+1):(3*s+s)] + S.move
      
      #and transform back
      nt1 <- transform.vect(vec=nt1_disease, s=c, c=s)
      
    }
    #fill in matrix
    N_pop_ts[,i+1] <- nt1
    

  }
  
  stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion")  
  
  #transform whole vector to be split by class instead of age
  N_pop_ts <- transform.vect(vec=N_pop_ts, s=20, c=4)
  
  
  N_split_1 = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
  
  #transform array into list
  N_split = list()
  for (i in 1:dim(N_split_1)[3]){
    N_split[[i]] = N_split_1[,,i]
  }
  
  #now you have a list of state variables.
  #then take column sums of each and plot the class totals over time - note that there are 26 steps per year
  N_total = lapply(X=N_split, FUN=colSums)
  
  #plot both by age and total
  #times=seq(0,yrs,by =1/ntyr)
  dat.tot = cbind.data.frame(times,N_total)
  names(dat.tot) = c("time", "M", "S", "I", "R")
  dat.tot$N = rowSums((dat.tot[,2:ncol(dat.tot)]))
  
  
  names(dat.tot)[names(dat.tot)=="N"] <- "tot_pop"
  
  
  dat.long <- melt(dat.tot, measure.vars = c("M", "S", "I", "R", "tot_pop"), variable.name = "state", value.name = "count")
  dat.sub = subset(dat.long, state!="tot_pop")
  dat.pop = subset(dat.long, state=="tot_pop")
  
  dat.pop <- dplyr::select(dat.pop, -(state))
  names(dat.pop)[names(dat.pop)=="count"] <- "tot_pop"
  
  dat.out <- merge(dat.sub, dat.pop, by ="time", all.x = T, sort = F)
  head(dat.out)
  dat.out$proportion <- dat.out$count/dat.out$tot_pop
  
  dat.out$state = factor(dat.out$state, levels=c("M", "S", "I", "R"))
  
  #and remove burnin:
  dat.out = subset(dat.out, time >= burnin)
  
  
  dat.out$model = model1
  dat.out$prop_vacc = prop.vacc
  
  
  if(length(vacc.biwk)==1){
    dat.out$biwk_vacc = vacc.biwk  
  }else{
    dat.out$biwk_vacc = paste(vacc.biwk, collapse = ", ") 
  }
  
  
  
  #return this sim
  return(dat.out)
  
}
sim.met.MSIRN.age.vax <- function(burnin, sim_pop, yrs, ntyr,  s, beta, age.brk, recov, mort, mort_juv, adult_fec, wane, rho, model1,
                                  slope.wane, sigma, mu.sick, add.inf.mort, N_stat, vacc.biwk, prop.vacc, year.vacc){
  #first pull out your data...
  c=5
  # dat.tmp <- subset(dat.age1, species==species1 & type==type1)
  #then run model for 100 years 
  #can take more timesteps than the data
  times <-   seq(0, yrs, by =1/ntyr) # then, subtract last few biweeks so you end before the last birthpulse starts. 
  #means ctting last 4 biweeks
  #times <- times[1:(length(times)-4)]
  
  
  
  #first, we take our juvenile and adult survival rates and use them to get the stable age structure
  mat1 = build.pop.mat(surv=(1-mort), surv_juv=(1-mort_juv), s=(s), adult_fec = adult_fec)
  
  stab.struct = Re(eigen(mat1)$vector[,1])
  stab.struct <- stab.struct/sum(stab.struct)
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
  
  #out of curiosity...
  lambda = round(max(Re(eigen(mat1)$value)), 8)
  #print(paste0("lambda = ", lambda)) #we need the pop to replace itself or grow slightly - must be 1 or greater
  #then, we use this stable age structure to make a bat population
  #gives counts of bats per age year
  bat.mat = stab.struct*sim_pop
  
  #introduce a few infecteds and run it out to equilibrium before you grab the data
  R_init = rep(0, s)
  I_init = rep(0, s); I_init[3] = 5 #comment out if you just want to check demography
  M_init = rep(0, s)
  N_init = rep(0, s)
  S_init = bat.mat - I_init 
  
  
  N_tot = cbind(M_init, S_init, I_init, R_init, N_init)
  
  N_pop = vec(N_tot) #by disease status
  M_pop = vec(t(N_tot)) #by age class
  
  #make matrix to store your population as you go
  N_pop_ts <- matrix(NA, ncol = length(times), nrow(N_pop))
  N_pop_ts[,1] <- M_pop # by age class
  
  
  stab.struct <- get.age.struct.M(M_pop, c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")
  
  
  # print("start ts")
  #iterate SIR such that this gets transitioned each timestep. And change the births as you go
  for (i in 1:(length(times)-1)){
    #build matrices anew each time because foi depends on # infected
    #calculate biweek from timestep here:
    biwk1 <- find.biweek(t=i, times=times)
    #  print(i)
    Tmat <- buildTMat_MSIRN_age(c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk = age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick, rho=rho,	beta=beta, sigma=sigma, recov=recov, wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    
    
    #Tmat <- buildTMat_MSIRN_age_seas(biwk=biwk1, c=c, Npop= N_pop_ts[,i], age.classes=1:s, age.brk = age.brk, surv.biwk = (1-mort)^(1/ntyr), surv.juv.biwk = (1-mort_juv)^(1/ntyr), mu.sick=mu.sick, boost=boost,	beta=beta, sigma=sigma, recov=recov, wane= wane, add.inf.mort=add.inf.mort, age.rate=1/ntyr, slope.wane=slope.wane)
    # print(i)
    
    # print(biwk1)
    
    #feed into fertility matrix since births are dependent on biwk
    Fmat <- buildFMatrix_MSIRN(age.classes=1:s, adult_fec =adult_fec, surv.biwk = (1-mort)^(1/ntyr), biwk = biwk1, N_stat = N_stat)
    
    #make trans mat
    transMat <- Tmat + Fmat 
    
    #move forward in time
    nt1<-(transMat) %*% N_pop_ts[,i]
    
    #then, add in vaccination event, depending on the biweek of the year
    if (sum(biwk1==vacc.biwk)>0 & floor(times[i])==year.vacc){
      #pop vector right now is organized by age class: M-1,S-1,I-1,R-1,M-2,S-2, etc.
      
      #move to by disease status
      #transform whole vector to be split by class instead of age
      nt1_disease <- transform.vect(vec=nt1, s=s, c=c)
      
      #now, move a proportion of the S class individuals to the R class for vaccination
      S.move <- nt1_disease[(s+1):(s+s)]*prop.vacc
      
      #take them out of S
      nt1_disease[(s+1):(s+s)] <- (nt1_disease[(s+1):(s+s)]-S.move)
      
      #put them in R
      
      nt1_disease[(3*s+1):(3*s+s)] <- nt1_disease[(3*s+1):(3*s+s)] + S.move
      
      #and transform back
      nt1 <- transform.vect(vec=nt1_disease, s=c, c=s)
      
    }
    #fill in matrix
    N_pop_ts[,i+1] <- nt1
  }
  
  stab.struct <- get.age.struct.M(pop=N_pop_ts[,ncol(N_pop_ts)], c=c)
  stab.struct <- c(unlist(stab.struct))
  stab.struct <- stab.struct/(sum(stab.struct))
  #plot(stab.struct, xlab="Age", ylab="Proportion", type="b")  
  
  #transform whole vector to be split by class instead of age
  N_pop_ts <- transform.vect(vec=N_pop_ts, s=s, c=c)
  
  
  N_split_1 = mat_split(N_pop_ts, r=s, c=ncol(N_pop_ts))
  
  #transform array into list
  N_split = list()
  for (i in 1:dim(N_split_1)[3]){
    N_split[[i]] = N_split_1[,,i]
  }
  
  #now you have a list of state variables.
  #then take column sums of each and plot the class totals over time - note that there are 26 steps per year
  N_total = lapply(X=N_split, FUN=colSums)
  
  #plot both by age and total
  #times=seq(0,yrs,by =1/ntyr)
  dat.tot = cbind.data.frame(times,N_total)
  names(dat.tot) = c("time", "M", "S", "I", "R", "N")
  dat.tot$tot_pop = rowSums((dat.tot[,2:ncol(dat.tot)]))
  
  
  
  dat.long <- melt(dat.tot, measure.vars = c("M", "S", "I", "R", "N", "tot_pop"), variable.name = "state", value.name = "count")
  dat.sub = subset(dat.long, state!="tot_pop")
  dat.pop = subset(dat.long, state=="tot_pop")
  
  dat.pop <- dplyr::select(dat.pop, -(state))
  names(dat.pop)[names(dat.pop)=="count"] <- "tot_pop"
  
  dat.out <- merge(dat.sub, dat.pop, by ="time", all.x = T, sort = F)
  head(dat.out)
  dat.out$proportion <- dat.out$count/dat.out$tot_pop
  
  dat.out$state = factor(dat.out$state, levels=c("M", "S", "I", "R", "N"))
  
  #and remove burnin:
  dat.out = subset(dat.out, time >= burnin)
  
  dat.out$model = model1
  dat.out$prop_vacc = prop.vacc
  
  if(length(vacc.biwk)==1){
    dat.out$biwk_vacc = vacc.biwk  
  }else{
    dat.out$biwk_vacc = paste(vacc.biwk, collapse = ", ") 
  }
  
  
  
  
  #return this sim
  return(dat.out)
}

#births happen in biweeks 1-4, 24-26
#let's have vaccination happen after waning maternal immunity 
#(this optimal timing is something we will eventually test)
#... so, after 4 months, or 8 biweeks, so around round biweek 12
#start with just one campaign

run.MSIRS <- sim.met.MSIR.age.vax(burnin=30, 
                                  sim_pop=10000, 
                                  yrs=50, 
                                  ntyr=26, 
                                  s=20, 
                                  beta = 1.57911, 
                                  age.brk = 20, 
                                  recov=1,  
                                  mort=.207, 
                                  mort_juv=0.456, 
                                  adult_fec=.48, 
                                  wane=1.08806987767265, #(3^(1/26))
                                  slope.wane=1, 
                                  sigma=0.0222735363575397, 
                                  mu.sick = 1, 
                                  add.inf.mort = FALSE,
                                  model1 = "MSIRS",
                                  vacc.biwk = 12,
                                  prop.vacc = 0,#proportion of S class vaccinated, eventually can think about "wasted" vaccines on those already exposed
                                  year.vacc= 33)


run.MSIRN <- sim.met.MSIRN.age.vax(burnin=30,
                                   sim_pop=10000,
                                   yrs=50,
                                   ntyr=26,
                                   s=20,
                                   beta = 2.203968,
                                   age.brk = 20,
                                   recov=1, 
                                   mort=.207,
                                   mort_juv=0.456,
                                   adult_fec=.48,
                                   wane=0.0850142487956748,
                                   slope.wane=1,
                                   sigma=0.00748049787194744,
                                   rho=0, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                   mu.sick = 1,
                                   add.inf.mort = FALSE, 
                                   N_stat="matAB",
                                   model1 = "MSIRN",
                                   vacc.biwk = 12,
                                   prop.vacc = 0,
                                   year.vacc= 33)


run.MSIRNI <- sim.met.MSIRN.age.vax(burnin=30,
                                    sim_pop=10000,
                                    yrs=50,
                                    ntyr=26,
                                    s=20,
                                    beta = 2.203968,
                                    age.brk = 20,
                                    recov=1, 
                                    mort=.207,
                                    mort_juv=0.456,
                                    adult_fec=.48,
                                    wane=0.0850142487956748,
                                    slope.wane=1,
                                    sigma=0.00748049787194744,
                                    rho= 1/24, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                    mu.sick = 1,
                                    add.inf.mort = FALSE, 
                                    N_stat="matAB",
                                    model1 = "MSIRNI",
                                    vacc.biwk = 12,
                                    prop.vacc = 0,
                                    year.vacc= 33)

#and with vaccines


run.MSIRS.1 <- sim.met.MSIR.age.vax(burnin=30, 
                                  sim_pop=10000, 
                                  yrs=50, 
                                  ntyr=26, 
                                  s=20, 
                                  beta = 1.57911, 
                                  age.brk = 20, 
                                  recov=1,  
                                  mort=.207, 
                                  mort_juv=0.456, 
                                  adult_fec=.48, 
                                  wane=1.08806987767265, #(3^(1/26))
                                  slope.wane=1, 
                                  sigma=0.0222735363575397, 
                                  mu.sick = 1, 
                                  add.inf.mort = FALSE,
                                  model1 = "MSIRS",
                                  vacc.biwk = 12,
                                  prop.vacc = .5,#proportion of S class vaccinated, eventually can think about "wasted" vaccines on those already exposed
                                  year.vacc= 33)

run.MSIRS.1$n_campaigns=1

run.MSIRN.1 <- sim.met.MSIRN.age.vax(burnin=30,
                                   sim_pop=10000,
                                   yrs=50,
                                   ntyr=26,
                                   s=20,
                                   beta = 2.203968,
                                   age.brk = 20,
                                   recov=1, 
                                   mort=.207,
                                   mort_juv=0.456,
                                   adult_fec=.48,
                                   wane=0.0850142487956748,
                                   slope.wane=1,
                                   sigma=0.00748049787194744,
                                   rho=0, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                   mu.sick = 1,
                                   add.inf.mort = FALSE, 
                                   N_stat="matAB",
                                   model1 = "MSIRN",
                                   vacc.biwk = 12,
                                   prop.vacc = .5,
                                   year.vacc= 33)
run.MSIRN.1$n_campaigns = 1


run.MSIRNI.1 <- sim.met.MSIRN.age.vax(burnin=30,
                                    sim_pop=10000,
                                    yrs=50,
                                    ntyr=26,
                                    s=20,
                                    beta = 2.203968,
                                    age.brk = 20,
                                    recov=1, 
                                    mort=.207,
                                    mort_juv=0.456,
                                    adult_fec=.48,
                                    wane=0.0850142487956748,
                                    slope.wane=1,
                                    sigma=0.00748049787194744,
                                    rho= 1/24, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                    mu.sick = 1,
                                    add.inf.mort = FALSE, 
                                    N_stat="matAB",
                                    model1 = "MSIRNI",
                                    vacc.biwk = 12,
                                    prop.vacc = .5,
                                    year.vacc= 33)

run.MSIRNI.1$n_campaigns=1


run.MSIRS.2 <- sim.met.MSIR.age.vax(burnin=30, 
                                    sim_pop=10000, 
                                    yrs=50, 
                                    ntyr=26, 
                                    s=20, 
                                    beta = 1.57911, 
                                    age.brk = 20, 
                                    recov=1,  
                                    mort=.207, 
                                    mort_juv=0.456, 
                                    adult_fec=.48, 
                                    wane=1.08806987767265, #(3^(1/26))
                                    slope.wane=1, 
                                    sigma=0.0222735363575397, 
                                    mu.sick = 1, 
                                    add.inf.mort = FALSE,
                                    model1 = "MSIRS",
                                    vacc.biwk = c(12, 20),
                                    prop.vacc = .5,#proportion of S class vaccinated, eventually can think about "wasted" vaccines on those already exposed
                                    year.vacc= 33)

run.MSIRS.2$n_campaigns=2

run.MSIRN.2 <- sim.met.MSIRN.age.vax(burnin=30,
                                     sim_pop=10000,
                                     yrs=50,
                                     ntyr=26,
                                     s=20,
                                     beta = 2.203968,
                                     age.brk = 20,
                                     recov=1, 
                                     mort=.207,
                                     mort_juv=0.456,
                                     adult_fec=.48,
                                     wane=0.0850142487956748,
                                     slope.wane=1,
                                     sigma=0.00748049787194744,
                                     rho=0, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                     mu.sick = 1,
                                     add.inf.mort = FALSE, 
                                     N_stat="matAB",
                                     model1 = "MSIRN",
                                     vacc.biwk = c(12, 20),
                                     prop.vacc = .5,
                                     year.vacc= 33)
run.MSIRN.2$n_campaigns = 2


run.MSIRNI.2 <- sim.met.MSIRN.age.vax(burnin=30,
                                      sim_pop=10000,
                                      yrs=50,
                                      ntyr=26,
                                      s=20,
                                      beta = 2.203968,
                                      age.brk = 20,
                                      recov=1, 
                                      mort=.207,
                                      mort_juv=0.456,
                                      adult_fec=.48,
                                      wane=0.0850142487956748,
                                      slope.wane=1,
                                      sigma=0.00748049787194744,
                                      rho= 1/24, #this is new from the paper, allows for N-class individuals to wane back to I (not S) so represents a persistent infection. in the future, could have this occur only seasonally
                                      mu.sick = 1,
                                      add.inf.mort = FALSE, 
                                      N_stat="matAB",
                                      model1 = "MSIRNI",
                                      vacc.biwk = c(12, 20),
                                      prop.vacc = .5,
                                      year.vacc= 33)

run.MSIRNI.2$n_campaigns=2



run.MSIRN$n_campaigns <- run.MSIRS$n_campaigns <- run.MSIRNI$n_campaigns <- 0

all.runs <-rbind(run.MSIRN, run.MSIRS, run.MSIRNI, 
                 run.MSIRN.1, run.MSIRS.1, run.MSIRNI.1,
                 run.MSIRN.2, run.MSIRS.2, run.MSIRNI.2)

all.runs$model <- factor(all.runs$model, levels = c("MSIRN", "MSIRS", "MSIRNI"))
all.runs$campaign_type[all.runs$prop_vacc==0] <- "no vaccination"
all.runs$campaign_type[all.runs$prop_vacc==0.5 & all.runs$n_campaigns==1] <- "1 campaign:\n50% vaccination"
all.runs$campaign_type[all.runs$prop_vacc==0.5 & all.runs$n_campaigns==2] <- "2 campaigns:\n50% vaccination"
all.runs$campaign_type <- factor(all.runs$campaign_type, levels = c("no vaccination", "1 campaign:\n50% vaccination", "2 campaigns:\n50% vaccination"))

save(all.runs, file = "simple.vax.sim.Rdata")

colz = c('M'="violet", 'S' = "mediumseagreen", 'I' = 'tomato', 'R' = "cornflowerblue", 'N' = "navy")
vax.event = cbind.data.frame(time=c((33 + 12/26),(33 + 12/26), (33+20/26)),
                             campaign_type=c("1 campaign:\n50% vaccination", "2 campaigns:\n50% vaccination", "2 campaigns:\n50% vaccination"))

vax.event$campaign_type = factor(vax.event$campaign_type, levels = c("no vaccination", "1 campaign:\n50% vaccination", "2 campaigns:\n50% vaccination"))

p1 <- ggplot(data=all.runs) + geom_line(aes(x=time, y=proportion, color=state)) +
  theme_bw() + theme(panel.grid = element_blank(), strip.background = element_rect(fill="white"), 
                     legend.direction = "horizontal", legend.title = element_blank(), legend.background = element_blank(),
                     legend.position = c(.16,.95), legend.text = element_text(size=7),
                     axis.title = element_text(size=18), axis.text = element_text(size=14), strip.text = element_text(size=18)) + 
  scale_color_manual(values=colz) + scale_x_continuous(breaks=seq(30,50,5), labels=c(0:4)) +
  geom_vline(data=vax.event, aes(xintercept=time), linetype=2) +
  facet_grid(model~campaign_type) + xlab("year of monitoring")

ggsave(file = "BatVaccineComp.png",
       plot=p1,
       units="mm",  
       width=70, 
       height=60, 
       scale=3, 
       dpi=300)
